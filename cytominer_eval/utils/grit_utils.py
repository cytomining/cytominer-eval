import numpy as np
import pandas as pd
from typing import List, Union
import pandas.api.types as ptypes
from collections import OrderedDict

from cytominer_eval.utils.operation_utils import compare_distributions
from cytominer_eval.utils.transform_utils import set_pair_ids
from cytominer_eval.utils.availability_utils import (
    check_replicate_summary_method,
    check_compare_distribution_method,
)


def calculate_grit(
    replicate_group_df: pd.DataFrame,
    control_perts: List[str],
    column_id_info: dict,
    distribution_compare_method: str = "zscore",
    replicate_summary_method: str = "mean",
) -> pd.Series:
    """Given an elongated pairwise correlation dataframe of replicate groups,
    calculate grit.

    Usage: Designed to be called within a pandas.DataFrame().groupby().apply(). See
    :py:func:`cytominer_eval.operations.grit.grit`.

    Parameters
    ----------
    replicate_group_df : pandas.DataFrame
        An elongated dataframe storing pairwise correlations of all profiles to a single
        replicate group.
    control_perts : list
        The profile_ids that should be considered controls (the reference)
    column_id_info: dict
        A dictionary of column identifiers noting profile and replicate group ids. This
        variable is autogenerated in
        :py:func:`cytominer_eval.transform.util.set_grit_column_info`.
    distribution_compare_method : {'zscore'}, optional
        How to compare the replicate and reference distributions of pairwise similarity
    replicate_summary_method : {'mean', 'median'}, optional
        How to summarize replicate z-scores. Defaults to "mean".

    Returns
    -------
    dict
        A return bundle of identifiers (perturbation, group) and results (grit score).
        The dictionary has keys ("perturbation", "group", "grit_score"). "grit_score"
        will be NaN if no other profiles exist in the defined group.
    """
    # Confirm that we support the user provided methods
    check_compare_distribution_method(distribution_compare_method)
    check_replicate_summary_method(replicate_summary_method)

    group_entry = get_grit_entry(replicate_group_df, column_id_info["group"]["id"])
    pert = get_grit_entry(replicate_group_df, column_id_info["profile"]["id"])

    # Define distributions for control perturbations
    control_distrib = replicate_group_df.loc[
        replicate_group_df.loc[:, column_id_info["profile"]["comparison"]].isin(
            control_perts
        ),
        "similarity_metric",
    ].values.reshape(-1, 1)

    assert len(control_distrib) > 1, "Error! No control perturbations found."

    # Define distributions for same group (but not same perturbation)
    same_group_distrib = replicate_group_df.loc[
        (
            replicate_group_df.loc[:, column_id_info["group"]["comparison"]]
            == group_entry
        )
        & (replicate_group_df.loc[:, column_id_info["profile"]["comparison"]] != pert),
        "similarity_metric",
    ].values.reshape(-1, 1)

    return_bundle = {"perturbation": pert, "group": group_entry}
    if len(same_group_distrib) == 0:
        return_bundle["grit"] = np.nan

    else:
        grit_score = compare_distributions(
            target_distrib=same_group_distrib,
            control_distrib=control_distrib,
            method=distribution_compare_method,
            replicate_summary_method=replicate_summary_method,
        )

        return_bundle["grit"] = grit_score

    return pd.Series(return_bundle)


def get_grit_entry(df: pd.DataFrame, col: str) -> str:
    """Helper function to define the perturbation identifier of interest

    Grit must be calculated using unique perturbations. This may or may not mean unique
    perturbations.
    """
    entries = df.loc[:, col]
    assert (
        len(entries.unique()) == 1
    ), "grit is calculated for each perturbation independently"
    return str(list(entries)[0])


def set_grit_column_info(profile_col: str, replicate_group_col: str) -> dict:
    """Transform column names to be used in calculating grit

    In calculating grit, the data must have a metadata feature describing the core
    replicate perturbation (profile_col) and a separate metadata feature(s) describing
    the larger group (replicate_group_col) that the perturbation belongs to (e.g. gene,
    MOA).

    Parameters
    ----------
    profile_col : str
        the metadata column storing profile ids. The column can have unique or replicate
        identifiers.
    replicate_group_col : str
        the metadata column indicating a higher order structure (group) than the
        profile column. E.g. target gene vs. guide in a CRISPR experiment.

    Returns
    -------
    dict
        A nested dictionary of renamed columns indicating how to determine replicates
    """
    # Identify column transform names
    pair_ids = set_pair_ids()

    profile_id_with_suffix = [
        "{col}{suf}".format(col=profile_col, suf=pair_ids[x]["suffix"])
        for x in pair_ids
    ]

    group_id_with_suffix = [
        "{col}{suf}".format(col=replicate_group_col, suf=pair_ids[x]["suffix"])
        for x in pair_ids
    ]

    col_info = ["id", "comparison"]
    profile_id_info = dict(zip(col_info, profile_id_with_suffix))
    group_id_info = dict(zip(col_info, group_id_with_suffix))

    column_id_info = {"profile": profile_id_info, "group": group_id_info}
    return column_id_info
